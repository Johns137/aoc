# -*- mode: org -*-
#+title: [[https://adventofcode.com/2019/day/12][Day 12: The N-Body Problem]]

* Moons

  N-body-/ish/ simulation problem. Moons update velocity based on
  relative position of planets. For each moon, for each dimension, the
  velocity is bumped by the sum of the signums of the differences
  between that moon and the others. Position is bumped by adding it to
  the bumped velocity.

#+BEGIN_SRC j :session :exports code
moons =: (|: 4 3 $ 3 2 _6 _13 18 10 _8 _1 13 5 10 4) ,. (3 4 $ 0)
eg =: (|: 4 3 $ _1 0 2 2 _10 _7 4 _8 8 3 5 _1) ,. (3 4 $ 0)

('position';(4{."1 eg)) ,: ('velocity';(4}."1 eg))
#+END_SRC

#+RESULTS:
: ┌────────┬────────────┐
: │position│_1   2  4  3│
: │        │ 0 _10 _8  5│
: │        │ 2  _7  8 _1│
: ├────────┼────────────┤
: │velocity│0 0 0 0     │
: │        │0 0 0 0     │
: │        │0 0 0 0     │
: └────────┴────────────┘

  So how to write the update? Let's isolate the position, do a
  difference table, take signum, and sum over dimensions.

#+BEGIN_SRC j :session :exports both
dv =: [: ([: +/ [: * [ -/ [) 4&{.    NB. position difference table, signum, sum
dp =: 4 |.!. 0 ]                     NB. shift velocity for add with pos, zeroing in
step =: ] + (4|.!.0])"1 + [: (],.]) ([: ([:+/[:*[-/[) 4&{.)"1 NB. put it all together
(; step) eg
#+END_SRC

#+RESULTS:
: ┌────────────────────┬─────────────────────┐
: │_1   2  4  3 0 0 0 0│ 2  3  1 2  3 1 _3 _1│
: │ 0 _10 _8  5 0 0 0 0│_1 _7 _7 2 _1 3  1 _3│
: │ 2  _7  8 _1 0 0 0 0│ 1 _4  5 0 _1 3 _3  1│
: └────────────────────┴─────────────────────┘

  Cool! The missing ingredient is /"energy."/ Energy is the sum of
  absolute values of components. Potential is that for position,
  kinetic is that for velocity. Total energy is the sum of the product
  of the two.

#+BEGIN_SRC j :session exports both
energy =: [: +/ [: (_4&{. * 4&{.) [: +/ |
(; energy) (step ^: 10) eg
#+END_SRC

#+RESULTS:
: ┌──────────────────────┬───┐
: │ 2  1  3 2 _3 _1  3  1│179│
: │ 1 _8 _6 0 _2  1  2 _1│   │
: │_3  0  1 4  1  3 _3 _1│   │
: └──────────────────────┴───┘

** PartA

#+BEGIN_SRC j :session :exports both
energy step ^: 1000 moons
#+END_SRC   

#+RESULTS:
: 14780


* Period

  Now the trickier part. We seek the period of the system, which is
  promised to be rather large.

  The axis are independent, so we can speed things up by only looking
  at one dimension at a time. The overall period is the least common
  multiple of the individual ones.

#+BEGIN_SRC j :session :exports code
period_rec =: (1 + [: $: 0&({::);[: step 1&({::))`1:@.(0&({::)-:1&({::))
wrap =: [: (];step) 1 8 $ {~

period =: 4 : 0
n=. 1 [z=. step ]y=. 1 8 $ x{y
while. -. z-:y do. n=. n+1 [z=. step z end. n
)
#+END_SRC

#+RESULTS:

** PartB

  And because I still haven't figured out org timeout issues with J,
  the solution is be presented on the small example:

#+BEGIN_SRC j :session :exports both
period_rec (eg; step eg)
NB. actual solution: *./ period&moons"0 i.3
#+END_SRC

#+RESULTS:
: 2772

  It takes around ~615~ ms to find the answer on the actual input
  ~moons~.
