(library (intcode)
  (export machine
          define-network
          run-until-halt
          feed)
  (import (chezscheme)
          (euler))

  (define (digit-at i n)
    (mod (quotient n (expt 10 (1+ i))) 10))

  (define (mode opcode param)
    (if (zero? (digit-at param opcode))
        'reference
        'immediate))

  (define (machine intcode ip)
    (define in '())
    (define out '())
    (define status 'ok)
    (define memory
      (list->vector intcode))
    (define (store! addr x)
      (vector-set! memory addr x))
    (define (ref addr) ;; not conditional reference
      (vector-ref memory addr))
    (define (cref opcode param) ;; conditional reference
      (case (mode opcode param)
        ((reference) (ref (ref (+ ip param))))
        ((immediate) (ref (+ ip param)))
        (else (error 'machine-ref "fixme"))))
    (define (step)
      (let ((op (ref ip)))
        (case (mod op 100)
          ((1)
           (store! (ref (+ ip 3)) (+ (cref op 1) (cref op 2)))
           (set! ip (+ ip 4)))
          ((2)
           (store! (ref (+ ip 3)) (* (cref op 1) (cref op 2)))
           (set! ip (+ ip 4)))
          ((3)
           (cond ((null? in)
                  (set! status 'no-in))
                 (else
                  (set! status 'ok)
                  (store! (ref (+ ip 1)) (pop! in))
                  (set! ip (+ ip 2)))))
          ((4)
           (set! status 'out)
           (push! (cref op 1) out)
           (set! ip (+ ip 2)))
          ((5)
           (if (zero? (cref op 1))
               (set! ip (+ ip 3))
               (set! ip (cref op 2))))
          ((6)
           (if (zero? (cref op 1))
               (set! ip (cref op 2))
               (set! ip (+ ip 3))))
          ((7)
           (store! (ref (+ ip 3)) (if (< (cref op 1) (cref op 2)) 1 0))
           (set! ip (+ ip 4)))
          ((8)
           (store! (ref (+ ip 3)) (if (= (cref op 1) (cref op 2)) 1 0))
           (set! ip (+ ip 4)))
          ((99) (set! status 'done))
          (else (error 'run "bad opcode" op)))))
    (lambda (me . args)
      (case me
        ((step) (step))
        ((in) (set! in `(,@in ,@args)))
        ((out) (if (null? out) 'no-out (car out)))
        ((status) status)
        ((dump) out))))

  (define (run-until-halt machine)
    (let run ()
      (machine 'step)
      (case (machine 'status)
        ((done) (machine 'dump))
        (else (run)))))

  ;; allow N to step out of no-in lock and aggressively run M

  (define (feed M N)
    (lambda ()
      (let run ()
        (case (M 'status)
          ((out) (N 'in (M 'out)) (N 'step) (M 'step) (run))
          ((no-in) 'blocked)
          ((done) 'done)
          (else (M 'step) (run))))))
  
  (define-syntax define-network
    (lambda (x)
      (syntax-case x (=> <- >?)
        ((_ (A ...) ((x => y) ...) ((m <- phase) ...) (?> T) intcode)
         #'(let ((A (machine intcode 0)) ...)
             (let ((loop (list (feed x y) ...)))
               (m 'in phase) ...
               (let run ()
                 (if (eq? 'done (T 'status))
                     (T 'out)
                     (let ((action (pop! loop)))
                       (let ((result (action)))
                         (unless (eq? result 'done)
                           (set! loop `(,@loop ,action)))
                         (run)))))))))))  
  
  )
