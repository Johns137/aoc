
(define (machine intcode ip)
  (define in '())
  (define out '())
  (define status 'ok)
  (define rb 0)
  (define memory
    `#(,@intcode ,@(make-list 100000 0)))
  (define (store! addr x)
    (vector-set! memory addr x))
  (define (cstore! addr x opcode param) ;; conditional store
    (case (mode opcode param)
      ((reference) (store! addr x))
      ((immediate) (error 'machine "impossible?" addr x opcode param))
      ((relative)  (store! (+ addr rb) x))
      (else (error 'machine-ref "fixme"))))
  (define (ref addr) ;; not conditional reference
    (vector-ref memory addr))
  (define (cref opcode param) ;; conditional reference
    (case (mode opcode param)
      ((reference) (ref (ref (+ ip param))))
      ((immediate) (ref (+ ip param)))
      ((relative)  (ref (+ rb (ref (+ ip param)))))
      (else (error 'machine-ref "fixme"))))
  (define (step)
    (let ((op (ref ip)))
      (case (mod op 100)
        ((1)
         (cstore! (ref (+ ip 3)) (+ (cref op 1) (cref op 2)) op 3)
         (set! ip (+ ip 4)))
        ((2)
         (cstore! (ref (+ ip 3)) (* (cref op 1) (cref op 2)) op 3)
         (set! ip (+ ip 4)))
        ((3)
         (cond ((null? in)
                (set! status 'no-in))
               (else
                (set! status 'ok)
                (cstore! (cref op 1) (pop! in) op 1)
                (set! ip (+ ip 2)))))
        ((4)
         (set! status 'out)
         (push! (cref op 1) out)
         (set! ip (+ ip 2)))
        ((5)
         (if (zero? (cref op 1))
             (set! ip (+ ip 3))
             (set! ip (cref op 2))))
        ((6)
         (if (zero? (cref op 1))
             (set! ip (cref op 2))
             (set! ip (+ ip 3))))
        ((7)
         (cstore! (ref (+ ip 3)) (if (< (cref op 1) (cref op 2)) 1 0) op 3)
         (set! ip (+ ip 4)))
        ((8)
         (cstore! (ref (+ ip 3)) (if (= (cref op 1) (cref op 2)) 1 0) op 3)
         (set! ip (+ ip 4)))
        ((9)
         (set! rb (+ rb (cref op 1)))
         (set! ip (+ ip 2)))
        ((99) (set! status 'done))
        (else (error 'run "bad opcode" op)))))
  (lambda (me . args)
    (case me
      ((step) (step))
      ((in) (set! in `(,@in ,@args)))
      ((out) (if (null? out) 'no-out (car out)))
      ((status) status)
      ((dump) (list 'in in 'ip ip 'rb rb 'out out)))))


;; allow N to step out of no-in lock and aggressively run M


(define (feed M N)
  (lambda ()
    (let run ()
      (case (M 'status)
        ((out) (N 'in (M 'out)) (N 'step) (M 'step) (run))
        ((no-in) 'blocked)
        ((done) 'done)
        (else (M 'step) (run))))))
  
(define-syntax define-network
  (lambda (x)
    (syntax-case x (=> <- >?)
      ((_ (A ...) ((x => y) ...) ((m <- phase) ...) (?> T) intcode)
       #'(let ((A (machine intcode 0)) ...)
           (let ((loop (list (feed x y) ...)))
             (m 'in phase) ...
             (let run ()
               (if (eq? 'done (T 'status))
                   (T 'out)
                   (let ((action (pop! loop)))
                     (let ((result (action)))
                       (unless (eq? result 'done)
                         (set! loop `(,@loop ,action)))
                       (run)))))))))))  
  
  
