(define (cpu intcode)
  (define ip 0)
  (define relative-base 0)
  (define status 'ok)
  (define cache1 `#(,@intcode))
  (define cache2 (make-eq-hashtable))
  (define size (vector-length cache1))
  (define in '())
  (define out '())

  (define (ip! dx)
    (set! ip (+ ip dx)))

  (define (rb! dx)
    (set! relative-base (+ relative-base dx)))
  
  (define (store! addr val)
    (if (fx< addr size)
        (vector-set! cache1 addr val)
        (hashtable-set! cache2 addr val)))
  
  (define (ref addr)
    (if (fx< addr size)
        (vector-ref cache1 addr)
        (hashtable-ref cache2 addr 0)))
  
  (define (val opcode param)
    (case (digit-at param opcode)
      ((1) (ref (+ ip param)))
      ((2) (ref (+ relative-base (ref (+ ip param)))))
      ((0) (ref (ref (+ ip param))))))

  (define (addr opcode param)
    (case (digit-at param opcode)
      ((2) (+ relative-base (ref (+ ip param))))
      ((0) (ref (+ ip param)))
      ((1) (error 'machine-addr "addr is immediate" opcode param))))
  
  (define (step)
    (let ((op (ref ip)))
      (case (fxmod op 100)
        ((1) (store! (addr op 3) (+ (val op 1) (val op 2))) (ip! 4))
        ((2) (store! (addr op 3) (* (val op 1) (val op 2))) (ip! 4))
        ((3) (if (null? in) (set! status 'blocking-in)
                 (begin (set! status 'ok) (store! (addr op 1) (pop! in)) (ip! 2))))
        ((4) (set! status 'out) (push! (val op 1) out) (ip! 2))
        ((5) (if (zero? (val op 1)) (ip! 3) (set! ip (val op 2))))
        ((6) (if (zero? (val op 1)) (set! ip (val op 2)) (ip! 3)))
        ((7) (store! (addr op 3) (if (< (val op 1) (val op 2)) 1 0)) (ip! 4))
        ((8) (store! (addr op 3) (if (= (val op 1) (val op 2)) 1 0)) (ip! 4))
        ((9) (rb! (val op 1)) (ip! 2))
        ((99) (set! status 'done))
        (else (error 'intcode "bad opcode" op)))))

  (define (run)
    (step)
    (case status
      ((done blocking-in out) (void))
      (else (run))))
  
  (define (dump)
    `(ip ,ip rb ,relative-base in ,in out ,out status ,status))

  (define (mem)
    `(cache1 ,cache1 cache2 ,cache2))

  (define (reset!)
    (set! cache1 `#(,@intcode))
    (set! cache2 (make-eq-hashtable))
    (set! ip 0)
    (set! relative-base 0)
    (set! in '())
    (set! out '())
    (set! status 'ok))

  (define (swap! program)
    (set! intcode program))
  
  (lambda (me . args)
    (case me
      ((step) (step))
      ((in) (set! in `(,@in ,@args)) (set! status 'ok))
      ((out) (if (null? out) 'no-out (car out)))
      ((run) (run))
      ((status) status)
      ((mem) (if (null? args) (mem) (map ref args)))
      ((ip) ip)
      ((ref) (apply ref args))
      ((rb) relative-base)
      ((swap!) (apply swap! args))
      ((reset!) (reset!))
      ((set-mem!) (apply store! args))
      ((dump) (dump))
      (else (error 'cpu "unknown message" me)))))

(define (dump-cache1 M)
  (list-ref (M 'mem) 1))

(define (dump-cache2 M)
  (hashtable-cells (list-ref (M 'mem) 3)))

(define (reset! M)
  (M 'reset!))

(define (step M)
  (M 'step))

(define (run M)
  (M 'run))

(define (run-until-halt machine)
  (let run ()
    (machine 'step)
    (case (machine 'status)
      ((done blocking-in) (machine 'dump))
      (else (run)))))

(define (feed M N)
  (lambda ()
    (let run ()
      (M 'run)
      (case (M 'status)
        ((out) (N 'in (M 'out)) (N 'step) (run))
        ((blocking-in) 'blocked)
        ((done) 'done)
        (else (run))))))

(define (feedback-loop machines)
  (map feed machines `(,@(cdr machines) ,(car machines))))

(define (spew machine)
  (display-ln (machine 'dump))
  (let run ()
    (machine 'step)
    (display-ln (machine 'mem))  
    (display-ln (machine 'dump))
    (case (machine 'status)
      ((done)
       (display-ln 'done))
      ((blocking-in)
       (display-ln 'blocking-in))
      (else (run)))))

(define (mode opcode param)
  (case (digit-at param opcode)
    ((1) 'immediate)
    ((2) 'relative)
    ((0) 'position)))

(define (pretty-mode opcode param)
  (case (digit-at param opcode)
    ((0) 'p)
    ((1) 'i)
    ((2) 'r)))

(define (pretty-instr instr)
  (case instr
    ((1) 'add)
    ((2) 'mul)
    ((3) 'red)
    ((4) 'out)
    ((5) 'jnz)
    ((6) 'jez)
    ((7) 'slt)
    ((8) 'seq)
    ((9) 'srb)
    ((99) 'ret)))

(define (pretty-opcode M)
  (let* ((ip (M 'ip)) (op (M 'ref ip)))
    (case (mod op 100)
      ((1) `(,ip (add  ,(pretty-mode op 1) ,(pretty-mode op 2) ,(pretty-mode op 3))))
      ((2) `(,ip (mul ,(pretty-mode op 1) ,(pretty-mode op 2) ,(pretty-mode op 3))))
      ((3) `(,ip (read ,(pretty-mode op 1))))
      ((4) `(,ip (out ,(pretty-mode op 1))))
      ((5) `(,ip (jnz ,(pretty-mode op 1) ,(pretty-mode op 2))))
      ((6) `(,ip (jez ,(pretty-mode op 1) ,(pretty-mode op 2))))
      ((7) `(,ip (lt ,(pretty-mode op 1) ,(pretty-mode op 2) ,(pretty-mode op 3))))
      ((8) `(,ip (eq ,(pretty-mode op 1) ,(pretty-mode op 2) ,(pretty-mode op 3))))
      ((9) `(,ip (rb ,(pretty-mode op 1))))
      ((99) `(,ip (return))))))

(define (%trace-control-flow M cutoff)
  (let run ((ips '()) (j 0))
    (if (= j cutoff)
        (reverse ips)
        (case (M 'status)
          ((done) (reverse (cdr ips)))
          ((blocking-in) (reverse ips))
          (else (M 'step) (run (cons (M 'ip) ips) (1+ j)))))))

(define trace-control-flow
  (case-lambda
    ((M) (%trace-control-flow M -1))
    ((M cutoff) (%trace-control-flow M cutoff))))

(define (%trace-opcodes M cutoff)
  (let run ((codes '()) (j 0))
    (if (= j cutoff)
        (reverse codes)
        (case (M 'status)
          ((done) (reverse (cdr codes)))
          ((blocking-in) (reverse codes))
          (else (M 'step) (run (cons (pretty-opcode M) codes) (1+ j)))))))

(define trace-opcodes
  (case-lambda
    ((M) (%trace-opcodes M -1))
    ((M cutoff) (%trace-opcodes M cutoff))))

(define (control-flow-graph trace)
  (let ((n (length trace)))
    (g:edges (map cons (list-head trace (1- n)) (cdr trace)))))

(define (potential-loops trace)
  (let* ((g (control-flow-graph trace))
         (sccs (vector->list (hashtable-cells (g:scc g)))))
    (filter (compose (curry < 1) length)
            (group-with (lambda (x y) (= (cdr x) (cdr y)))
                        (sort-on sccs cdr)))))
