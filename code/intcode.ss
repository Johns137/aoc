(define (cpu intcode)
  (define ip 0)
  (define relative-base 0)
  (define status 'ok)
  (define cache1 `#(,@intcode))
  (define cache2 (make-eq-hashtable))
  (define size (vector-length cache1))
  (define in '())
  (define out '())

  (define (ip! dx)
    (set! ip (+ ip dx)))

  (define (rb! dx)
    (set! relative-base (+ relative-base dx)))
  
  (define (store! addr val)
    (if (fx< addr size)
        (vector-set! cache1 addr val)
        (hashtable-set! cache2 addr val)))
  
  (define (ref addr)
    (if (fx< addr size)
        (vector-ref cache1 addr)
        (hashtable-ref cache2 addr 0)))
  
  (define (val opcode param)
    (case (digit-at param opcode)
      ((1) (ref (+ ip param)))
      ((2) (ref (+ relative-base (ref (+ ip param)))))
      ((0) (ref (ref (+ ip param))))))

  (define (addr opcode param)
    (case (digit-at param opcode)
      ((2) (+ relative-base (ref (+ ip param))))
      ((0) (ref (+ ip param)))
      ((1) (error 'machine-addr "addr is immediate" opcode param))))
  
  (define (step)
    (let ((op (ref ip)))
      (case (fxmod op 100)
        ((1) (store! (addr op 3) (+ (val op 1) (val op 2))) (ip! 4))
        ((2) (store! (addr op 3) (* (val op 1) (val op 2))) (ip! 4))
        ((3) (if (null? in) (set! status 'blocking-in)
                 (begin (set! status 'ok) (store! (addr op 1) (pop! in)) (ip! 2))))
        ((4) (set! status 'out) (push! (val op 1) out) (ip! 2))
        ((5) (if (zero? (val op 1)) (ip! 3) (set! ip (val op 2))))
        ((6) (if (zero? (val op 1)) (set! ip (val op 2)) (ip! 3)))
        ((7) (store! (addr op 3) (if (< (val op 1) (val op 2)) 1 0)) (ip! 4))
        ((8) (store! (addr op 3) (if (= (val op 1) (val op 2)) 1 0)) (ip! 4))
        ((9) (rb! (val op 1)) (ip! 2))
        ((99) (set! status 'done))
        (else (error 'intcode "bad opcode" op)))))

  (define (dump)
    `(ip ,ip rb ,relative-base in ,in out ,out status ,status))

  (define (mem)
    `(cache1 ,cache1 cache2 ,cache2))

  (define (reset!)
    (set! cache1 `#(,@intcode))
    (set! cache2 (make-eq-hashtable))
    (set! ip 0)
    (set! relative-base 0)
    (set! in '())
    (set! out '())
    (set! status 'ok))

  (define (copy! cache1* cache2* ip* rb* in* out* status*)
    (set! ip ip*)
    (set! relative-base rb*)
    (set! cache1 (vector-copy cache1*))
    (set! cache2 (eq-hashtable-copy cache2*))
    (set! in in*)
    (set! out out*)
    (set! status status*))

  (lambda (me . args)
    (case me
      ((step) (set! status 'ok) (step) status)
      ((in) (set! in `(,@in ,@args)) (set! status 'ok))
      ((out) (if (null? out) 'no-out (car out)))
      ((read-out!) (let ((tmp (reverse out))) (set! out '()) tmp))
      ((status) status)
      ((mem) (if (null? args) (mem) (apply ref args)))
      ((ip) ip)
      ((rb) relative-base)
      ((ref) (apply ref args))
      ((dump) (dump))
      ((reset!) (reset!))
      ((set-mem!) (apply store! args))
      ((cache1) cache1)
      ((cache2) cache2)
      ((peek-in) in)
      ((peek-out) (reverse out))
      ((intcode) intcode)
      ((copy!) (apply copy! args))
      (else (error 'cpu "unknown message" me)))))

(define (copy-intcode M)
  ;; lol DANGER!
  ;;   (copy! cache1* cache2* ip* rb* in* out* status*)
  (define M* (cpu (M 'intcode)))
  (M* 'copy!
      (M 'cache1)
      (M 'cache2)
      (M 'ip)
      (M 'rb)
      (M 'peek-in)
      (M 'peek-out)
      (M 'status))
  M*)

(define (dump-cache1 M)
  (list-ref (M 'mem) 1))

(define (dump-cache2 M)
  (hashtable-cells (list-ref (M 'mem) 3)))

(define (read-memory M addr)
  (M 'mem addr))

(define (store! M addr val)
  (M 'set-mem! addr val))

(define (reset! M)
  (M 'reset!))

(define (step M)
  (M 'step))

(define (run M)
  (M 'run))

(define (send-input M value)
  (M 'in value))

(define (read-output M)
  (M 'read-out!))

(define (get-output M)
  (M 'out))

(define (status M)
  (M 'status))

(define (run-until status M)
  (let run ((s (step M)))
    (if (memq s status) s (run (step M)))))

(define (run-until-halt M)
  (run-until '(done blocking-in) M))

(define (done? M)
  (eq? 'done (status M)))

(define (blocked? M)
  (eq? 'blocking-in (status M)))

(define (mode opcode param)
  (case (digit-at param opcode)
    ((1) 'immediate)
    ((2) 'relative)
    ((0) 'position)))

(define (pretty-mode opcode param)
  (case (digit-at param opcode)
    ((0) 'p)
    ((1) 'i)
    ((2) 'r)))

(define (pretty-instr instr)
  (case instr
    ((1) 'add)
    ((2) 'mul)
    ((3) 'red)
    ((4) 'out)
    ((5) 'jnz)
    ((6) 'jez)
    ((7) 'slt)
    ((8) 'seq)
    ((9) 'srb)
    ((99) 'ret)))

(define (pretty-opcode M)
  (let* ((ip (M 'ip)) (op (M 'ref ip)))
    (case (mod op 100)
      ((1) `(,ip (add ,(pretty-mode op 1) ,(pretty-mode op 2) ,(pretty-mode op 3))))
      ((2) `(,ip (mul ,(pretty-mode op 1) ,(pretty-mode op 2) ,(pretty-mode op 3))))
      ((3) `(,ip (read ,(pretty-mode op 1))))
      ((4) `(,ip (out ,(pretty-mode op 1))))
      ((5) `(,ip (jnz ,(pretty-mode op 1) ,(pretty-mode op 2))))
      ((6) `(,ip (jez ,(pretty-mode op 1) ,(pretty-mode op 2))))
      ((7) `(,ip (lt ,(pretty-mode op 1) ,(pretty-mode op 2) ,(pretty-mode op 3))))
      ((8) `(,ip (eq ,(pretty-mode op 1) ,(pretty-mode op 2) ,(pretty-mode op 3))))
      ((9) `(,ip (rb ,(pretty-mode op 1))))
      ((99) `(,ip (return))))))

(define (%trace-control-flow M cutoff)
  (let run ((ips '()) (j 0))
    (if (= j cutoff)
        (reverse ips)
        (case (step M)
          ((done blocking-in) (reverse ips))
          (else (run (cons (M 'ip) ips) (1+ j)))))))

(define trace-control-flow
  (case-lambda
    ((M) (%trace-control-flow M -1))
    ((M cutoff) (%trace-control-flow M cutoff))))

(define (%trace-opcodes M cutoff)
  (let run ((codes '()) (j 0))
    (if (= j cutoff)
        (reverse codes)
        (case (step M)
          ((done blocking-in) (reverse codes))
          (else (run (cons (pretty-opcode M) codes) (1+ j)))))))

(define trace-opcodes
  (case-lambda
    ((M) (%trace-opcodes M -1))
    ((M cutoff) (%trace-opcodes M cutoff))))

(define (control-flow-graph trace)
  (let ((n (length trace)))
    (g:edges (map cons (list-head trace (1- n)) (cdr trace)))))

(define (potential-loops trace)
  (let* ((g (control-flow-graph trace))
         (sccs (vector->list (hashtable-cells (g:scc g)))))
    (filter (compose (curry < 1) length)
            (group-with (lambda (x y) (= (cdr x) (cdr y)))
                        (sort-on cdr sccs)))))
