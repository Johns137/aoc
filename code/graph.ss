
(define (hashtable-for-object v)
  (cond ;; ...
   ((complex? v) (make-eqv-hashtable))
   ((inexact? v) (make-eqv-hashtable))
   ((list? v) (make-hashtable equal-hash equal?))
   ((integer? v) (make-eq-hashtable v))
   ((symbol? v) (make-eq-hashtable v))
   ((string? v) (make-hashtable string-hash string=?))
   ((vector? v) (make-hashtable equal-hash equal?))
   (else (make-hashtable equal-hash equal?))))

(define-record-type dfs-result
  (fields parents order))

(define-record-type bfs-result
  (fields parents distances))

(define dfs
  (lambda (v adjacent)
    (define seen (hashtable-for-object v))
    (define parents (hashtable-for-object v))
    (define exit-order '())
    (let dfs ((v v))
      (unless (hashtable-ref seen v #f)
        (hashtable-set! seen v #t)
        (for-all (lambda (w)
                   (hashtable-set! parents w v)
                   (dfs w))
                 (adjacent v))
        (push! v exit-order)))
    (make-dfs-result parents)))

(define bfs
  (lambda (v adjacent)
    (define seen (hashtable-for-object v))
    (define parents (hashtable-for-object v))
    (define distances (hashtable-for-object v))
    (let bfs ((Q (q:consq (cons 0 v) q:empty)))
      (unless (q:empty? Q)
        (let ((d.v (q:headq Q)))
          (let ((d (car d.v)) (v (cdr d.v)))
            (hashtable-set! distances v d)
            (bfs (fold-left (lambda (Q w)
                              (cond ((not (hashtable-ref seen w #f))
                                     (hashtable-set! seen w #t)
                                     (hashtable-set! parents w v)
                                     (q:snocq Q (cons (1+ d) w)))
                                    (else Q)))
                            (q:tailq Q)
                            (adjacent v)))))))
    (make-bfs-result parents distances)))

(define (bfs-distance u v adjacent)
  (hashtable-ref (bfs-result-distances (bfs u adjacent))
                 v
                 -1))

;; (define topological-sort
;;   (lambda (G)
;;     (call/cc
;;      (lambda (cyclic)
;;        (let ((seen (make-hash-table))
;;              (tree (make-hash-table))
;;              (ordering '()))
;;          (define (dfs-state v)
;;            (hashtable-ref seen v #f))
;;          (define (find-cycle head cycle)
;;            (if (eq? head (car cycle))
;;                cycle
;;                (find-cycle head
;;                            (cons (hashtable-ref tree
;;                                                 (car cycle)
;;                                                 #f)
;;                                  cycle))))
;;          (define (enter x y)
;;            (hashtable-set! seen y 'entered)
;;            (hashtable-set! tree y x))
;;          (define (exit y)
;;            (hashtable-set! seen y 'exited)
;;            (push! y ordering))
;;          (define (dfs x)
;;            (for-each (lambda (y)
;;                        (let ((y-state (dfs-state y)))
;;                          (cond ((eq? y-state 'entered)
;;                                 (cyclic (cons 'cyclic (find-cycle y (list x)))))
;;                                ((eq? y-state 'exited))
;;                                (else
;;                                 (enter x y)
;;                                 (dfs y)
;;                                 (exit y)))))
;;                      (adjacent-descending x G)))
;;          (for-each (lambda (v)
;;                      (unless (dfs-state v)
;;                        (dfs v)
;;                        (exit v)))
;;                    (vertex-list-descending G))
;;          (cons 'dag ordering))))))
;; 
;; (define acyclic?
;;   (lambda (G)
;;     (eq? 'dag (car (topological-sort G)))))
;; 
;; (define dag?
;;   (lambda (G)
;;     (acyclic? G)))
;; 
;; (define scc
;;   (lambda (G)
;;     (let ((preorder 0)
;;           (component 0)
;;           (preorders (make-hash-table))
;;           (components (make-hash-table))
;;           (boundary '())
;;           (path '()))
;;       (define (preorder-id v)
;;         (hashtable-ref preorders v #f))
;;       (define (component-id v)
;;         (hashtable-ref components v #f))
;;       (define (set-component! v)
;;         (hashtable-set! components v component))
;;       (define (set-preorder! v)
;;         (hashtable-set! preorders v preorder)
;;         (inc! preorder))
;;       (define (enter v)
;;         (set-preorder! v)
;;         (push! v boundary)
;;         (push! v path))
;;       (define (pop-boundary v)
;;         (let ((p-v (preorder-id v)))
;;           (let walk ((x (pop! boundary)))
;;             (if (< p-v (preorder-id x))
;;                 (walk (pop! boundary))
;;                 (push! x boundary)))))
;;       (define (exit v)
;;         (when (= v (car boundary))
;;           (pop! boundary)
;;           (set-component! v)
;;           (let walk ((x (pop! path)))
;;             (unless (= x v)
;;               (set-component! x)
;;               (walk (pop! path))))
;;           (inc! component)))
;;       (define (dfs u)
;;         (enter u)
;;         (for-all (lambda (v)
;;                    (if (preorder-id v)
;;                        (unless (component-id v)
;;                          (pop-boundary v))
;;                        (dfs v)))
;;                  (adjacent u G))
;;         (exit u))
;;       (for-all (lambda (v)
;;                  (unless (preorder-id v)
;;                    (dfs v)))
;;                (vertex-list G))
;;       components)))
;; 
;; (define scc-count
;;   (lambda (G)
;;     (fx1+ (fold-left fxmax -1 (vector->list (hashtable-values (scc G)))))))
;; 
