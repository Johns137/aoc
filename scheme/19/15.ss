(load "~/code/advent/load.ss")
(advent-year 19)
(advent-day 15)

(import (prefix (pairing-heap) h:))

(define intcode
  (parse-advent comma-separated))

(define north 1)
(define south 2)
(define east 4)
(define west 3)
(define wall 0)
(define moved 1)
(define oxygen-system 2)

(define (news z)
  `(,(+ z 1) ,(- z 1) ,(+ z 0+i) ,(+ z 0-i)))

(define (dir->instr z)
  (match z
    (1 east)
    (-1 west)
    (0+i north)
    (0-i south)))

(define g (make-eqv-hashtable))
(define m (cpu intcode))
(define loc 0)
(define tank)

(define (random-element lst)
  (list-ref lst (random (length lst))))

(define (next)
  (define options '())
  (define new '())
  (filter (lambda (z)
            (match (hashtable-ref g z 'idk)
              ('idk (push! z new))
              ('wall (void))
              ('open (push! z options))
              ('tank (push! z options)))
            )
          (news loc))
  (if (null? new)
      (random-element options)
      (random-element new)))

(define (explore lim)
  (let run ((i lim))
    (unless (zero? i)
      (let ((z (next)))
        (m 'in (dir->instr (- z loc)))
        (run-until-halt m)
        ;;        (display-ln (m 'dump))
        (match (read-output m)
          ((0) (hashtable-set! g z 'wall))
          ((1) (hashtable-set! g z 'open) (set! loc z))
          ((2) (hashtable-set! g z 'tank) (set! loc z) (set! tank z)))
        (run (1- i))))))

(define (showme)
  (do ((i -30 (1+ i)))
      ((= i 30))
    (do ((j -30 (1+ j)))
        ((= j 30) (newline))
      (if (and (zero? i)
               (zero? j))
          (display #\H)
          (match (hashtable-ref g (make-rectangular i j) 'idk)
            ('idk (display #\?))
            ('wall (display #\#))
            ('open (display #\.))
            ('tank (display #\T)))))))

(define (findme)
  (define seen (make-eqv-hashtable))
  (define q (q:snocq q:empty '(0 . 0)))
  (define n 0)
  (define found #f)
  (define dist)
  (let loop ()
    (unless found
      (inc! n)
      (match (q:headq q)
        ((d . z)
         (set! q (q:tailq q))
         (unless (hashtable-ref seen z #f)
           (hashtable-set! seen z #t)
           (display-ln q)
           (for-all (lambda (z)
                      (match (hashtable-ref g z 'idk)
                        ('wall (void))
                        ('idk  (void))
                        ('open (set! q (q:snocq q (cons (1+ d) z))))
                        ('tank (set! dist (1+ d)) (set! found #t))))
                    (news z)))))
      (loop)))
  dist)

(define (fillme)
  (define seen (make-eqv-hashtable))
  (define q (q:snocq q:empty (cons 0 tank)))
  (define n 0)
  (define found #f)
  (define dist 0)
  (let loop ()
    (unless (q:empty? q)
      (inc! n)
      (match (q:headq q)
        ((d . z)
         (display-ln q)
         (set! q (q:tailq q))
         (unless (hashtable-ref seen z #f)
           (set! dist (max d dist))

           (hashtable-set! seen z #t)
           ;;
           
           (for-all (lambda (z)
                      (match (hashtable-ref g z 'idk)
                        ('wall (void))
                        ('idk  (display-ln "oops") (void))
                        ('open (set! q (q:snocq q (cons (1+ d) z))))
                        ('tank (set! q (q:snocq q (cons (1+ d) z))))))
                    (news z)))))
      (loop)))
  dist)
